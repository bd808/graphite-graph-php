<?php

namespace Graphite\Graph;

class CallSpecTest extends \PHPUnit_Framework_TestCase
{
    /**
     * Given: a call spec with the '<' modifier
     * Expect: the first arg to be the hoisted value
     */
    public function test_hoist_modifier()
    {
        $s = new CallSpec('mostDeviant', '#<');
        $this->assertSame('mostDeviant(1234,*)', $s->asString('*', [1234]));

        $s = new CallSpec('f', ['-', '-<']);
        $this->assertSame('f(2,*,1)', $s->asString('*', 1, 2));
    }

    /**
     * Given: a call spec with the '?' modifier
     * Expect: empty string, null and bool values to be omitted from call
     */
    public function test_optional_modifier()
    {
        $s = new CallSpec('f', ['-?']);

        $this->assertSame('f(series)', $s->asString('series', null));
        $this->assertSame('f(series)', $s->asString('series', ''));
        $this->assertSame('f(series)', $s->asString('series', true));
        $this->assertSame('f(series)', $s->asString('series', false));

        $this->assertSame('f(series,0)', $s->asString('series', 0));
        $this->assertSame('f(series,1)', $s->asString('series', 1));
    }

    /**
     * Given: a function expecting a boolean type
     * Expect: standard php bool casting
     */
    public function test_boolean_coersion()
    {
        $s = new CallSpec('f', ['^']);

        $this->assertSame('f(series,True)', $s->asString('series', true));
        $this->assertSame('f(series,True)', $s->asString('series', '1'));
        $this->assertSame('f(series,True)', $s->asString('series', 1));
        $this->assertSame('f(series,True)', $s->asString('series', '-1'));
        $this->assertSame('f(series,True)', $s->asString('series', -1));
        $this->assertSame('f(series,True)', $s->asString('series', 'most strings'));
        $this->assertSame('f(series,True)', $s->asString('series', [1]));

        $this->assertSame('f(series,False)', $s->asString('series', false));
        $this->assertSame('f(series,False)', $s->asString('series', 0));
        $this->assertSame('f(series,False)', $s->asString('series', 0.0));
        $this->assertSame('f(series,False)', $s->asString('series', ''));
        $this->assertSame('f(series,False)', $s->asString('series', '0'));
        $this->assertSame('f(series,False)', $s->asString('series', []));
        $this->assertSame('f(series,False)', $s->asString('series', null));
    }

    /**
     * Given: a function expecting a numeric type
     * Expect: numeric coersion
     */
    public function test_numeric_coersion()
    {
        $s = new CallSpec('f', ['#']);

        $this->assertSame('f(series,1)', $s->asString('series', 1));
        $this->assertSame('f(series,1)', $s->asString('series', '1'));
        $this->assertSame('f(series,0.1)', $s->asString('series', 1E-1));
        $this->assertSame('f(series,0.1)', $s->asString('series', 1e-1));
        $this->assertSame(
            'f(series,0.00000095)',
            $s->asString('series', 1 / (1024 * 1024))
        );

        $this->assertSame('f(series)', $s->asString('series', null));
        $this->assertSame('f(series)', $s->asString('series', 'fruit'));
    }

    /**
     * Given: a list of callspecs
     * Expect: proper sorting
     */
    public function test_sort_order()
    {
        // php's quicksort isn't stable, so no use checking for that
        // by using dup values in the control.
        $sorted = [
            new CallSpec('0', ['-'], 1),
            new CallSpec('1', ['-'], 10),
            new CallSpec('2', ['-'], 20),
            new CallSpec('3', ['-'], 30),
            new CallSpec('4', ['-'], 40),
            new CallSpec('5', ['-'], 50),
            new CallSpec('6', ['-'], 99),
        ];

        $clone = unserialize(serialize($sorted));
        // make sure we start sorted
        // NOTE: assertSame doesn't work here
        $this->assertEquals($sorted, $clone);

        usort($clone, [CallSpec::class, 'cmp']);
        $this->assertEquals($sorted, $clone, 'sorted -> sorted');

        $clone = array_reverse($clone);
        usort($clone, [CallSpec::class, 'cmp']);
        $this->assertEquals($sorted, $clone, 'reverse -> sorted');

        shuffle($clone);
        usort($clone, [CallSpec::class, 'cmp']);
        $this->assertEquals($sorted, $clone, 'shuffle -> sorted');
    }

    /**
     * Given: a collection of argument strings
     * Expect: proper parsing
     */
    public function test_parse_arg_strings()
    {
        $this->assertEquals(
            ['1', '2', '3'],
            CallSpec::parseArgString('1,2,3')
        );

        $this->assertEquals(
            ['1,2,3'],
            CallSpec::parseArgString('1\\,2\\,3')
        );

        $this->assertEquals(
            ['1,2,3'],
            CallSpec::parseArgString('"1,2,3"')
        );

        $this->assertEquals(
            ['1,2,3'],
            CallSpec::parseArgString("'1,2,3'")
        );

        $this->assertEquals(
            ['1', 'the number "2"', '3'],
            CallSpec::parseArgString('1,the number \\"2\\",3')
        );

        $this->assertEquals(
            ['^.*TCP(\d+)', ' \1'],
            CallSpec::parseArgString("'^.*TCP(\d+)', '\\1'")
        );

        $this->assertEquals(
            ['1', '2', '3,4,5', '6,7', '"8', "'9", '10,11', '\\n'],
            CallSpec::parseArgString(
                '1,2,"3,4,5",\'6,7\',\\"8,\\\'9,10\\,11,"\n"'
            )
        );
    }
}
